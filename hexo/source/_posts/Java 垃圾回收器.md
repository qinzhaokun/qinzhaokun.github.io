---
title: Java 垃圾回收器
date: 2017-09-22
tags: Java
categories: Java
---

本篇讲解垃圾回收的具体实现。由于Java虚拟机规范中对垃圾回收器应该如何实现没有明确的规定，因此，不同的厂商都会有自己的实现。

## 并发 && 并行

**并行**是Parallel, 是指多条垃圾回收线程并行的工作，这时用户的业务线程是被挂起的，造成了`Stop the world`

**并发**是Concurrent, 用户的线程和垃圾回收线程并发执行，共同抢占CPU时间。一般意义来说,不会造成`Stop the world`

## Serial收集器

串行垃圾回收收集器，最基本，最简单，历史最悠久的收集器

## CMS(Concurrent Mark-Sweep) 垃圾收集器

CMS(Concurrent Mark-Sweep)是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动JVM参数加上-XX:+UseConcMarkSweepGC ，这个参数表示对于老年代的回收采用CMS。

### 清理步骤

+ 初始标记 ：在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法STW(Stop The Word)。这个过程从垃圾回收的"根对象"开始，只扫描到能够和"根对象"直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。

+ 并发标记 ：这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。

+ 并发预清理 ：并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代， 或者有一些对象被分配到老年代)。通过重新扫描，减少下一个阶段"重新标记"的工作，因为下一个阶段会Stop The World。

+ 重新标记 ：这个阶段会暂停虚拟机，收集器线程扫描在CMS堆中剩余的对象。扫描从"根对象"开始向下追溯，并处理对象关联。

+ 并发清理 ：清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。

+ 并发重置 ：这个阶段，重置CMS收集器的数据结构，等待下一次垃圾回收。

### 缺点

+ 使用标记清理会产生空间碎片

+ 需要更多CPU资源

+ 需要更大的堆空间

CMS回收器减少了回收的停顿时间，但是降低了堆空间的利用率。

http://www.jianshu.com/p/50d5c88b272d
