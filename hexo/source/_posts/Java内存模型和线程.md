---
title: Java内存模型和线程
date: 2017-07-21
tags: Java
categories: Java
---
由于处理器的速度和内存读写的速度差异很大，造成了处理器花很大一部分时间去进行内存读写。因此，计算系统筒加入了高速缓存，以减少处理器等待数据读写的时间。但是, 由于多个处理器对应多个高速缓存，它们共享同一个主存，因此，存在缓存一致性的问题。在主存进行读写时，会遵循缓存一致性协议。此外，处理器会对代码进行乱序执行以充分利用资源，执行的结果会保证和顺序执行的结果一直，即指令重排序优化。

## Java内存模型

Java Memory Model， JMM， 它由Java定义，来屏蔽掉各种硬件和操作系统内存访问的差异，让程序能够在不同的平台达到一致性并发的效果

### 主内存和工作内存

所有的变量都存储在主内存当中，每条线程还有自己的工作内存，类似于高速缓存，**线程保存着被该线程使用到的变量的拷贝**，线程对变量的操作在工作内存中，不直接写主存。线程操作其他线程的工作内存。

#### 内存间的交互操作

主内存和工作内存之间的数据同步需要一些操作来完成，Java内存模型定义了几种操作来完成：

+ lock（锁定）：作用于主存，把主存的变量标记某个线程独占

+ unlock（解锁）：作用于主存，把其从锁定状态释放出来

+ read（读取）：主存读取到工作内存

+ load（载入）：作用于工作内存，把read操作得到的值放入到工作内存中。

+ use（使用）：作用于工作内存，把变量传递给执行器引擎

+ assign（赋值）：作用于工作内存，把执行引擎得到的值赋值给工作内存变量

+ store（存储）：作用于工作内存，把工作内存中的一个变量值传送给主内存中，为write操作

+ write（写入）：作用于主内存，写入主存

由上面分析，read和load必须同时出现，store和write必须同时出现，但是不保证一定顺序执行，有可能read和load之间有其他操作。
