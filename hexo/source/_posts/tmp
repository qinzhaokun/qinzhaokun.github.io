import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

public class RPCServer {
	
	
	public static void main(String[] args) throws IOException {
		
		Selector mainSelector = Selector.open();
		
		ServerSocketChannel ssc = ServerSocketChannel.open();
		
		ssc.configureBlocking(false);
		
		ssc.bind(new InetSocketAddress(8080));
		
		ssc.register(mainSelector, SelectionKey.OP_ACCEPT);
		
		int coreNum = Runtime.getRuntime().availableProcessors();
		
		Processor [] processor = new Processor[coreNum];
		
		for(int i = 0; i < coreNum; i++){
			processor[i] = new Processor();
		}
		
		int index = 0;
		while(!Thread.currentThread().isInterrupted()){
			mainSelector.select();
			Set<SelectionKey> keys = mainSelector.selectedKeys();
			Iterator<SelectionKey> iter = keys.iterator();
			while(iter.hasNext()){
				SelectionKey key = iter.next();
				if(key.isAcceptable()){
					SocketChannel socketChannel = ((ServerSocketChannel)key.channel()).accept();
					socketChannel.configureBlocking(false);
					processor[index++ % coreNum].register(socketChannel, SelectionKey.OP_READ);
					processor[(index-1) % coreNum].wakeup();
				}
				
				iter.remove();
				//
				if(index == coreNum){
					index = 0;
				}
			}
		}
		
	}

}

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.ByteBuffer;
import java.nio.channels.ClosedChannelException;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.nio.channels.spi.SelectorProvider;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import netdata.RpcRequest;

public class Processor {
	private Selector selector;
	
	private ByteBuffer buffer;
	private static final Map<String, Class<?>> serverMethods = new HashMap();

	
	private static final ExecutorService es = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
	
	Processor() throws IOException{
		selector = SelectorProvider.provider().openSelector();
		serverMethods.put("serviceInterface.HelloWorld", LiMing.class);
		buffer = ByteBuffer.allocate(1024);
		start();
	}
	
	public void register(SocketChannel sc, int key) throws ClosedChannelException{
		sc.register(selector, key);
	}
	public void wakeup() {
		this.selector.wakeup();
    }
	
	private void start(){
		es.submit(() -> {
			while(!Thread.currentThread().isInterrupted()){
				try {
			        if (selector.select(500) <= 0) {
			            continue;
			          }
					//System.out.println("get three " + Thread.currentThread().getName());
					Set<SelectionKey> keys = selector.selectedKeys();
					Iterator<SelectionKey> iter = keys.iterator();
					while(iter.hasNext()){
						SelectionKey key = iter.next();
						iter.remove();
						if (key.isReadable()) {
							SocketChannel sc = (SocketChannel)key.channel();
							RpcRequest req = read(sc);
							if(req != null){
								Object obj = invoke(req);
								System.out.println(obj);
								sc.write(ByteBuffer.wrap(obj.toString().getBytes()));
						
							}
							
						}
					}
				} catch (Exception e) {

					e.printStackTrace();
				}
			}
		});
	}
	
	private RpcRequest read(SocketChannel channel) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchMethodException, SecurityException{
        int count = channel.read(buffer);   
        RpcRequest req = null;
        if (count > 0) {   
            buffer.flip(); 
            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(buffer.array()));
            //String message = new String(buffer.array());
            //req = new RpcRequest(message); 
            req = (RpcRequest)ois.readObject();
        } else {   
            channel.close();   
        }   
        buffer.clear(); 
        return req;
	}
	
	private Object invoke(RpcRequest req) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException{
		Class<?> service = serverMethods.get(req.getClassName());
		
		Method method = service.getMethod(req.getMethodName(), req.getParamTypes());
		
		Object ret = method.invoke(service.newInstance(), req.getParams());
	
		return ret;
	}
}


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectOutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.net.ServerSocket;
import java.net.Socket;

import netdata.RpcRequest;
import serviceInterface.HelloWorld;
//import ;
public class DynamicProxy implements InvocationHandler{

/*	@Override
	public Object invoke(Object object, Method method, Object[] params) throws Throwable {
		Socket socket = new Socket("127.0.0.1", 8080);
		socket.setSoTimeout(60000);
       
        PrintWriter printWriter =new PrintWriter(socket.getOutputStream(),true);
        
        
        String message = "1;"+HelloWorld.class.getName()+";"+method.getName()+";";
        for(int i = 0; i < params.length; i++){
        	message += params[i].getClass().getName();
        	if(i != params.length - 1){
        		message += ",";
        	}
        }
        message += ";";
        for(int i = 0; i < params.length; i++){
        	message += params[i].toString();
        	if(i != params.length - 1){
        		message += ",";
        	}
        }
        printWriter.println(message);
        // 刷新输出流，使Server马上收到该字符串
        printWriter.flush();


        BufferedReader bufferedReader =new BufferedReader(new InputStreamReader(socket.getInputStream()));

        String result = bufferedReader.readLine();

        Class<?> c = method.getReturnType();
        Object ret = c.getConstructor(result.getClass()).newInstance(result);

       
        printWriter.close();
        
		return ret;
	}
*/
	
	@Override
	public Object invoke(Object object, Method method, Object[] params) throws Throwable {
		Socket socket = new Socket("127.0.0.1", 8080);
		//socket.setSoTimeout(60000);
        /** 发送客户端准备传输的信息 */
        ObjectOutputStream printWriter =new ObjectOutputStream(socket.getOutputStream());
        // 将输入读入的字符串输出到Server
        //BufferedReader sysBuff =new BufferedReader(new InputStreamReader(System.in));
        String message = "1;"+HelloWorld.class.getName()+";"+method.getName()+";";
        for(int i = 0; i < params.length; i++){
        	message += params[i].getClass().getName();
        	if(i != params.length - 1){
        		message += ",";
        	}
        }
        message += ";";
        for(int i = 0; i < params.length; i++){
        	message += params[i].toString();
        	if(i != params.length - 1){
        		message += ",";
        	}
        }
        
        System.out.println(message);
        
        RpcRequest req = new RpcRequest(message);
        printWriter.writeObject(req);
        // 刷新输出流，使Server马上收到该字符串
        printWriter.flush();


        BufferedReader bufferedReader =new BufferedReader(new InputStreamReader(socket.getInputStream()));

        String result = bufferedReader.readLine();

        Class<?> c = method.getReturnType();
        Object ret = c.getConstructor(result.getClass()).newInstance(result);

        /** 关闭Socket*/
        printWriter.close();
        
		return ret;
	}
	
	public static HelloWorld getProxy(){

		return (HelloWorld)Proxy.newProxyInstance(HelloWorld.class.getClassLoader(), new Class[]{HelloWorld.class}, new DynamicProxy());
	}
	
	

}

 通道可以是单向的，也可以是双向的，而流只能是单向的（InputStream和OutputStream）。
 
 通道可以是阻塞的，也可以是非阻塞的。非阻塞模式的通道永远
 
 不会让调用的线程休眠。请求的操作要么立即完成,要么返回一个结果表明未进行任何操作。这也是NIO为什么能够实现非阻塞的I/O。
 
 `Channel`是一个顶层接口，该接口定义简单：
 ```
 public interface Channel extends Closeable {
    public boolean isOpen();
    public void close() throws IOException;
}
 ```
 
**通道能够访问I/O服务**，主要可以分为文件通道和套接字通道。FileChannel对象却只能通过一个打开的RandomAccessFile、FileInputStream或FileOutputStream的对象上调用getChannel()方法获取，不可以直接创建

#### Socket通道

关于Socket通道，有三个主要的类，`ServerSocketChannel`, `SocketChannel`和`DatagramChannel`. 他们都继承自`AbstractSelectableChannel`.`ServerSocketChannel`主要是鉴定传入的连接和去创建新的`SocketChannel`对象，该通道不会传递数据，而后面两个会有数据传输。这三种通道被实例化时都会创建对等的socket对象，(Socket、ServerSocket和DatagramSocket)

通过调用configureBlocking(booelan block)去设置socket通道的模式。

##### ServerSocketChannel

用静态的`open()`工厂方法创建一个新的`ServerSocketChannel`实例，将会返回和一个`java.net.ServerSocket`关联的通道。下一步就是要使用`bind()`方法绑定一个地址。`ServerSocketChannel`也有`accept()`方法。一旦创建了一个`ServerSocketChannel`，并且对等的`ServerSocket`绑定了端口，然后就可以在其中一个上调用`accept()`方法了。如果选择在`ServerSocket`上调用，则总是阻塞并返回一个`java.net.Socket`对象，如果选择在`ServerSocketChannel`上调用，则会返回`SocketChannel`类型的对象，返回的对象能够在非阻塞模式下运行。

##### SocketChannel

`Socket`和`SocketChannel`类封装点对点、有序的网络连接，类似TCP/IP网络连接。可以通过`SocketChannel`的静态方法`open()`创建新的`SocketChannel`对象，调用`socket()`方法可以返回对应的`Socket`对象。新创建的 SocketChannel 虽已打开却是未连接的。因此，可以通过`connect()`连接服务端，`sc.connect(new InetSocketAddress ("localhost", 1234));`

##### DatagramChannel

它是面向UDP协议的。
