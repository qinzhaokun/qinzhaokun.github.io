---
title: JVM 性能调优
date: 2017-09-28
tags: Java
categories: Java
---

## Full GC

减少Full GC的频率

减少Young GC和Full GC的时间

GC 调优对高并发大数据量交互的应用还是很有必要的，尤其是默认 JVM 参数通常不满足业务需求，需要进行专门调优。由于系统堆设置较大，Full GC 一次暂停应用时间会较长，这对线上实时服务影响较大

1. 最好的GC算法是**Concurrent Mark Sweep（CMS垃圾回收）**，特别是对于Web服务端程序。因为低延迟是非常重要的。

2. 新生代（Young generation）的空间太小，导致有一些本应该可以很快就被回收的对象被放到了老生代（Old generation）里，导致老生代上涨很快，频繁`Full GC`。**增加新生代的大小**,**修改后，Yong GC都在10ms下，达到了想要的效果**。建议新生代占整个堆的1/4~1/2

3. full gc还是比较多，且持续时间较长。ygc的对象进入老年代，是按照年龄计算的，这个年龄默认是15，但是是动态调整的，所以加这个参数，再观察一下。 查看日志可以看出，对象动态调整年龄是4

> 为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到Max Tenuring Threshold才能晋升老年代如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到Max Tenuring Threshold中要求的年龄。

因此，需要调大survivor，增加SurvivorRatio = 6

> 如果一个大对象同时又是一个短命的对象，假设这种情况出现很频繁，那对于 GC 来说会是一场灾难。原本应该用于存放永久对象的年老代，被短命的对象塞满，这也意味着对堆空间进行了洗牌，扰乱了分代内存回收的基本思路.因此，控制直接进入Old generation的threshold也是很重要的

## 总结主要调优参数：

### 设定堆内存大小

-Xms：启动JVM时的堆内存空间。

-Xmx：堆内存最大限制。

### 设定新生代大小

新生代不宜太小，否则会有大量对象涌入老年代。

-XX:NewRatio：新生代和老年代的占比。

-XX:NewSize：新生代空间。

-XX:SurvivorRatio：伊甸园空间和幸存者空间的占比。

-XX:MaxTenuringThreshold：对象进入老年代的年龄阈值。

### 设定老生代大小

老生代太大，每次Full GC的时间会很长，太小，则Full GC会比较频繁。

## 设定垃圾回收器

年轻代：-XX:+UseParNewGC。

老年代：-XX:+UseConcMarkSweepGC。

CMS可以将STW时间降到最低，但是不对内存进行压缩，有可能出现“并行模式失败”。比如老年代空间还有300MB空间，但是一些10MB的对象无法被顺序的存储。这时候会触发压缩处理，但是CMS GC模式下的压缩处理时间要比Parallel GC长很多。
G1采用”标记-整理“算法，解决了内存碎片问题，建立了可预测的停顿时间类型，能让使用者指定在一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。

