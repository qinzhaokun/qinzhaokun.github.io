---
title: 建造者模式
date: 2017-07-10 18:18:25
tags: 设计模式
categories: 设计模式
---

建造者模式(Builder Pattern)，又称生成器模式，官方定如下：

> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

> 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的**类型**和**内容**就可以构建它们，用户不需要知道内部的具体构建细节。

下面给出具体的代码实现：

## 代码实现

### 定义产品

产品抽象类：
```
public abstract class Person{
  protected String head;
  
  protected String body;
  
  protected String leg;
 
 public abstract void setHead(String head);
 
 public abstract void setBody(String body);
 
 public abstract void setLeg(String leg);
}
```

产品实现类：
```
public class Man extends Person{
  public void setHead(head){
    this.head = head;
  }
  
  public void setBody(String body){
    this.body = body;
  }
  
  public void setLeg(String leg){
    this.leg = leg;
  }
}
```
### 定义建造者

建造者抽象类
```
public interfaceBuilder{
  public abstract void buildHead();
  
  public abstract void buildBoay();
  
  public abstract void builderLeg();
}
```

建造者实现类
```
public ManBuilder implements Builder{
  private Person person = new ManPerson();
  public void buildHead(){
    person.setHead("Man's Head");
  }
  
  public void buildBody(){
    person.setBody("Man's body");
  }
  
  public void buildLeg(){
    person.setLeg("Man's leg");
  }
  
  //或者有参数的
  public void buildHead(String head){
    person.setHead(head);
  }
  
  public void buildBody(String body){
    person.setBody(body);
  }
  
  public void buildLeg(String leg){
    person.setLeg(leg);
  }
  
  Person getPerson(){
    return person;
  }
}

### 指挥者
```
public class Director{
  private Builder builder = null;
  
  Director(Builder builder){
    this.builder = builder;
  }
  
  public Person construct(){
    builder.setHead();
    builder.setBoay();
    builder.setLeg();
    return builder.getPerson();
  }
  
  public Person construct(String head,String body,String leg){
    builder.setHead(head);
    builder.setBoay(body);
    builder.setLeg(leg);
    return builder.getPerson();
  }
}

### 测试类

class Test{
  public static void main(){
    Builder builder = new ManBuilder();
    Director d = new Director(builder);
    Person p = d.construct();
  }
}

## 模式分析

回想建造者的定义，它将复杂对象的构建（Builder/ManBuilder）和对象的表示（Person/ManPerson）分离了，不同的构建可以创造出不同的对象，但这些对象都是属于Person. 同样的，用户可以指定person中的head,leg,body便可构造它们（当然，完全可以通过构造函数来实现）

## 优缺点

### 优点

1. 解耦，复杂对象的表示和创建分开了，用户不需要知道产品内部的细节，而只需关注创建该产品需要提供什么参数，相同的创建过程创建了不同对象。

2. 提供多种建造者，建造者之间彼此独立，很容易添加新的建造者或修改建造者，而不影响其他的建造者（不需要修改其它地方的代码）

3. 创建过程更精细，有利于严格控制产品的每一部分

### 缺点

1. 只适用于产品间相似度很高的一类产品的创建，不适合差异较大的

2. 类的数量增多，系统变得庞大。

## 建造者模式VS工厂模式

### 意图不同

工厂模式注重创建出对象的整体，无需关心每个部分，细节如何被创建；建造者模式注重的是一步一步构建出对象，注重细节和构建的顺序

### 复杂度不同

工厂模式生成的对象大多是功能单一，也可说是**单一产品**；而建造者模式则是较复杂的对象，即复合产品（由多个部件构成）。特别是由于某个部件的不用，导致不同的产品
