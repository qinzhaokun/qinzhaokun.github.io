---
title: 代理模式
date: 2017-8-1
taps: 设计模式
categries: 设计模式
---

## 背景

某些情况下，客户不想或不可以直接引用一个对象，只能通过一个称之为“代理”的第三方来间接引用。它起到一个中介的作用，通过代理对象，能够去掉客户不想看到的内容，或者添加客户需要的内容。


## 代码示例

```
class RealOject{
  void say(){
    System.out.println("I am realObject.");
  }
}

class Proxy{
  private RealOject realSubject;
  
  public Proxy(){
    realOject = new RealOject();
  }
  
  private void preSay(){
    System.out.println("Hi");
  }
  
  private void afterSay(){
    System.out.println("Bye");
  }
  
  public void say(){
    preSay();
    realSubject.say();
    afterSay();
  }
}

//client

public class Test{
  public static void main(){
    Proxy p = new Proxy();
    p.say();
  }
}
```
上面是一个简单的代理模式，`RealObject`是被代理的类，而`Proxy`是代理类，代理类持有一个被代理类的对象，并且有一个相同名字的方法，当想调用被代理类方法时，通过代理调用，并且代理类可以增加一些功能。

## 优点

1. 协调调用者和被调用者，**降低系统耦合度**

2. 远程代理使得客户端访问远程机器上的对象

3. 使用小对象代表大对象，减少系统资源消耗，对系统优化并提速

4. 控制对**真实对象的使用权限**

5. **不修改原始代码的情况下，对方法进行增强**（如日志记录，验证权限，数据库连接和释放，Cache等

## 缺点

1. 增加了中间层，会造成请求速度变慢

2. 实现代理模式需要而外的工作，有些代理模式实现非常复杂

3. 当方法数量增多时，对应代理的方法也会增多，造成代码量增加（Java动态代理可解决）

## 使用环境

1. 远程代理：不同地址空间的对象提供一个本地代理对象

2. 虚拟代理：需要创建一个资源消耗较大的对象，先创建资源小的代理对象，真实的     对象只有需要的时候在被创建

3. 保护代理：控制客户端的访问权限，提供不同级别的权限




