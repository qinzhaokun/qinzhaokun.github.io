---
title: 垃圾回收策略与内存分配机制
date: 2017-06-22 20:18:25
tags: Java
categories: Java
---

说起垃圾回收，需要提起三件事：

+ 哪些需要回收

+ 什么时候回收

+ 怎么回收

## 对象“已死”？

在进行垃圾回收之前，第一步需要判断的就是哪些对象还存活着，哪些对象已经死去

### 引用计数法

给每个实例对象添加一个引用计数器，每当有一个地方引用它，计数器值就加1，当引用失效时，计数器就减1。它的特点有**实现简单**，**效率高**，在大多数情况下是不错的选择。但有一个严重的缺陷，就是无法解决**相互引用**。

### 根搜索法（GC Roots Tracing）

这是一种非常常用的，用于判断对象是否存活的方式，在主要的商用的Java虚拟机都是使用该方式。该方法的基本思路是通过一系列的“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，如果某个对象没有任何引用链到达GC roots时，证明该对象不可用，因此可以判定其是可回收的对象。

可作为GC Roots对象的包含下面几种：

+ 虚拟机栈（栈帧中的本地变量）对象的引用

+ 方法区类类的静态属性引用的对象（即被标识为static的变量）

+ 方法区中的常量引用对象

+ 本地方法栈的引用对象

### 在谈引用

在JDK1.2之前，引用的定义很传统，如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用，这样定义的对象只有两种状态，要么被引用，要么没有。我们更希望能够描述这样一种对象，当内存空间还足够时，则能保留在内存中，而如果内存在进行垃圾回收后还十分紧张，则可以抛弃这些对象，即缓存这样的场景。

因此在JDK1.2后，引用得以扩充，分为强引用（Strong Reference），软引用（Soft Reference），弱引用（Weak Reference）和虚引用（Phantom Reference），强度依次减弱。

+ 强引用就是指在代码中普遍存在的，Obj obj = new Object()的引用，只要有强引用，对象永远不会被回收

+ 软引用用来描述你一些还有用，但是非必须的对象，对于关联软引用的对象，在系统将要发生内存溢出异常之前，将会把这些对象进行二次回收，如果仍没有足够的内存，才会抛出内存溢出异常。使用SoftReference类来实现

+ 弱引用也是描述非必须的对象，被它关联的对象，只能生存到下一次垃圾回收发生之前，当垃圾回收时，无论内存是否足够，都会被回收，系统提供WeakReference类来实现弱引用。

+ 虚引用也被称为幽灵引用，是四种当中最弱的，一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例，它存在的目的是希望这个对象被回收时得到一个系统通知，系统PhantomRefernece来实现虚引用。

### 生存还是死亡？

有时候对象不可达，也不一定是“非死不可”，这时候它暂时处于“缓刑”阶段，真正判断对象已经死亡了，要经历两个过程。 通过根搜索法发现对象没有到达GC Roots的引用链，它会被**第一次标记**，然后再**筛选**，条件是有没有必要执行finalize()方法，如果对象没有覆盖该方法，或该方法已经被执行过，则马上需要回收，否则，将该对象放在一个F-Queue队列中。虚拟机的一个线程去调用该方法。队列中，虚拟机线程对其进行二次标记，如果还是标记上了，则需要回收了，如果能够在finalize方法中关联上一个到达GC Roots的引用，则能够“死里逃生”。

关于finalize方法，之前觉得它的作用是可以释放一些非java虚拟机管理的内存，但是这个方法被认定是Java向C++析构的妥协，对于释放资源，使用try-catch更好，因此建议忘掉该方法。

### 方法区的回收

方法区一般不进行垃圾回收的，因为回收的效率很低，有些虚拟机堆方法区是不进行回收的，但是不代表方法区不能进行回收。如果回收方法区的内存，主要回收**废弃常量**和**无用的类**。

**废弃常量**的回收和普通对象的回收一样。

**无用的类**的回收条件比较严格，要满足以下三个条件才可以进行回收

+该类的所有实例均已被回收，即堆中不存在该类的对象

+ 加载该类的classLoader被回收

+ 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
